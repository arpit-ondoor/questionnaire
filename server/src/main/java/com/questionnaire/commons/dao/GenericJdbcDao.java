package com.questionnaire.commons.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.BatchPreparedStatementSetter;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.ColumnMapRowMapper;
import org.springframework.jdbc.core.InterruptibleBatchPreparedStatementSetter;
import org.springframework.jdbc.core.JdbcOperations;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.ParameterDisposer;
import org.springframework.jdbc.core.PreparedStatementCallback;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.RowMapperResultSetExtractor;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.JdbcUtils;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.questionnaire.commons.exceptions.application.BusinessException;
import com.questionnaire.commons.generics.dao.RowUnMapper;
import com.questionnaire.model.OptionChoices;

/**
 * @author Arpit A
 *
 */
@Repository
public abstract class GenericJdbcDao<E> 
//implements InitializingBean, BeanFactoryAware 
{

	protected final Logger logger = LoggerFactory.getLogger(getClass());

	@Autowired
	private JdbcTemplate jdbcTemplate;

	protected Class<?> daoType;
	public static final String COMMA = ", ";

	private String tableName = null;
	private String idColumn = null;

	private Class<E> type = null;
	// private Class<? extends RowMapper> mapper = null;

	private final RowMapper<E> rowMapper;

	public GenericJdbcDao(String tableName, Class<E> type, RowUnMapper<E> rowUnmapper) {
		this(tableName, type, rowUnmapper, null, null);
	}

	public GenericJdbcDao(String tableName, Class<E> type, RowUnMapper<E> rowUnmapper, String idColumn) {
		this(tableName, type, rowUnmapper, idColumn, null);
	}

	public GenericJdbcDao(String tableName, Class<E> type, RowUnMapper<E> rowUnmapper, RowMapper<E> rowMapper) {
		this(tableName, type, rowUnmapper, null, rowMapper);
	}

	public GenericJdbcDao(String tableName, Class<E> type, RowUnMapper<E> rowUnmapper, String idColumn,
			RowMapper<E> rowMapper) {

		if (idColumn == null)
			idColumn = "id";
		this.idColumn = idColumn;
		if (rowMapper == null)
			rowMapper = new BeanPropertyRowMapper<E>(type);
		this.rowMapper = rowMapper;

		Assert.notNull(rowMapper);
		// Assert.notNull(rowUnmapper);
		Assert.notNull(type);
		Assert.notNull(idColumn);
		this.rowUnmapper = rowUnmapper;
		setType(type);
		setTable(tableName);
		table = new TableDescription(tableName, idColumn);

	}

	private void setType(Class<E> type) {
		this.type = type;
	}

	public Class<E> getType() {
		return this.type;
	}

	protected JdbcTemplate getJdbcTemplate() {
		return this.jdbcTemplate;
	}

	private void setTable(String name) {
		if (name != null)
			tableName = name;
	}

	public String getTable() {
		return tableName;
	}

//	private void obtainJdbcTemplate() {
//		try {
//			jdbcOperations = beanFactory.getBean(JdbcOperations.class);
//		} catch (NoSuchBeanDefinitionException e) {
//			final DataSource dataSource = beanFactory.getBean(DataSource.class);
//			jdbcOperations = new JdbcTemplate(dataSource);
//		}
//	}

//	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
//		this.beanFactory = beanFactory;
//	}

	public void setJdbcOperations(JdbcOperations jdbcOperations) {
		this.jdbcOperations = jdbcOperations;
	}

//	public void afterPropertiesSet() throws Exception {
//		obtainJdbcTemplate();
//
//	}

	private final RowUnMapper<E> rowUnmapper;
//	private BeanFactory beanFactory;
	@Autowired
	private JdbcOperations jdbcOperations;
	private final TableDescription table;

	public  E create(E entity) throws BusinessException {
		final Map<String, Object> columns = preCreate(columns(entity), entity);
		System.out.println("columns :" + columns);
		return createWithAutoGeneratedKey(entity, columns);
	}

	public  List<E> createAll(List<E> entities) throws BusinessException {
		Map<String, Object> columns=columns(entities.get(0));
		removeIdColumns(columns);
		String createQuery=null;
		if(columns!=null)
			createQuery = create(table, columns);
		return createAllWithAutoGeneratedKey(createQuery,entities);
	}

	private  List<E> createAllWithAutoGeneratedKey(String createQuery, List<E> entities) {
		
		batchUpdateWithKeyHolder(jdbcTemplate,
				createQuery,
                new BatchPreparedStatementSetterWithKeyHolder<E>(entities) {
                    @Override
                    protected void setValues(PreparedStatement ps, E entity) throws SQLException {
                    	
                    	LinkedHashMap<String, Object> columns = columns(entity);
            			removeIdColumns(columns);
            			Object[] entityParams = columns.values().toArray();
        				for (int j = 0; j < entityParams.length; ++j) {
        					ps.setObject(j + 1, entityParams[j]);
        				}
                    }
                    @Override
                    protected void setPrimaryKey(Map<String, Object> primaryKey, E entity) {
                    	entity=rowUnmapper.setId(entity, ((Long)primaryKey.get("GENERATED_KEY")).intValue());
                    }
                });
		
		return entities;
	}
	
	
	private void appendColumnNames(StringBuilder createQuery, Set<String> columnNames) {
		for (Iterator<String> iterator = columnNames.iterator(); iterator.hasNext();) {
			final String column = iterator.next();
			createQuery.append(column);
			if (iterator.hasNext()) {
				createQuery.append(COMMA);
			}
		}
	}

	public String create(TableDescription table, Map<String, Object> columns) {
		final StringBuilder createQuery = new StringBuilder("INSERT INTO " + table.getName() + " (");
		appendColumnNames(createQuery, columns.keySet());
		createQuery.append(")").append(" VALUES (");
		createQuery.append(repeat("?", COMMA, columns.size()));
		return createQuery.append(")").toString();
	}

	private static String repeat(String s, String separator, int count) {
		StringBuilder string = new StringBuilder((s.length() + separator.length()) * count);
		while (--count > 0) {
			string.append(s).append(separator);
		}
		return string.append(s).toString();
	}

	private  E createWithAutoGeneratedKey(E entity, Map<String, Object> columns) {
		removeIdColumns(columns);
		final String createQuery = create(table, columns);
		final Object[] queryParams = columns.values().toArray();
		final GeneratedKeyHolder key = new GeneratedKeyHolder();
		jdbcOperations.update(new PreparedStatementCreator() {

			public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
				final String idColumnName = table.getIdColumns().get(0);
				final PreparedStatement ps = con.prepareStatement(createQuery, new String[] { idColumnName });
				for (int i = 0; i < queryParams.length; ++i) {
					ps.setObject(i + 1, queryParams[i]);
				}
				return ps;
			}
		}, key);
		Integer id = key.getKey().intValue();
		entity=	rowUnmapper.setId(entity, id);
		return entity;
	}

	protected Map<String, Object> preCreate(Map<String, Object> columns, E entity) {
		return columns;
	}

	protected  E postCreate(E entity, Number generatedId) {
		return entity;
	}

	private LinkedHashMap<String, Object> columns(E entity) {
		return new LinkedHashMap<String, Object>(rowUnmapper.mapColumns(entity));
	}

	private List<Object> removeIdColumns(Map<String, Object> columns) {
		List<Object> idColumnsValues = new ArrayList<Object>(columns.size());
		for (String idColumn : table.getIdColumns()) {
			idColumnsValues.add(columns.remove(idColumn));
		}
		return idColumnsValues;
	}
	
	@Transactional(readOnly = true)
	public List<E> findAll() throws BusinessException {

		return jdbcTemplate.query("select * from " + getTable(), rowMapper);
	}

	
	public static <T> int[] batchUpdateWithKeyHolder(JdbcTemplate jdbcTemplate, final String sql, final BatchPreparedStatementSetterWithKeyHolder<T> pss) {
        return jdbcTemplate.execute(new PreparedStatementCreator() {
            @Override
            public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                return con.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            }
        }, new PreparedStatementCallback<int[]>() {
            @Override
            public int[] doInPreparedStatement(PreparedStatement ps) throws SQLException, DataAccessException {
                try {
                    int batchSize = pss.getBatchSize();
                    InterruptibleBatchPreparedStatementSetter ipss =
                            (pss instanceof InterruptibleBatchPreparedStatementSetter ?
                            (InterruptibleBatchPreparedStatementSetter) pss : null);
                    int[] result;
                    KeyHolder keyHolder = new GeneratedKeyHolder();

                    try {
                        if (JdbcUtils.supportsBatchUpdates(ps.getConnection())) {
                            for (int i = 0; i < batchSize; i++) {
                                pss.setValues(ps, i);
                                if (ipss != null && ipss.isBatchExhausted(i)) break;
                                ps.addBatch();
                            }
                            result = ps.executeBatch();

                            generatedKeys(ps, keyHolder);
                        } else {
                            List<Integer> rowsAffected = new ArrayList<Integer>();
                            for (int i = 0; i < batchSize; i++) {
                                pss.setValues(ps, i);
                                if (ipss != null && ipss.isBatchExhausted(i)) break;

                                rowsAffected.add(ps.executeUpdate());
                                generatedKeys(ps, keyHolder);
                            }

                            result = rowsAffected.stream().mapToInt(Integer::intValue).toArray();
                            
                        }
                    } finally {
                        pss.setPrimaryKey(keyHolder);
                    }

                    return result;
                } finally {
                    if (pss instanceof ParameterDisposer) ((ParameterDisposer) pss).cleanupParameters();
                }
            }
        });
    }
	
	private static void generatedKeys(PreparedStatement ps, KeyHolder keyHolder) throws SQLException {
        List<Map<String, Object>> keys = keyHolder.getKeyList();
        ResultSet rs = ps.getGeneratedKeys();
        if (rs == null) return;
        try {
            keys.addAll(new RowMapperResultSetExtractor<Map<String, Object>>(new ColumnMapRowMapper(), 1).extractData(rs));
        } finally {
            rs.close();
        }
    }
}

//final Object[] queryParams = columnsList.toArray();
/*		final GeneratedKeyHolder key = new GeneratedKeyHolder();
jdbcTemplate.batchUpdate(createQuery, new BatchPreparedStatementSetter() {

	@Override
	public void setValues(PreparedStatement ps, int i) throws SQLException {
		 Object[] entityParams = (Object[])queryParams[i];
		for (int j = 0; j < entityParams.length; ++j) {
			ps.setObject(j + 1, entityParams[j]);
		}
	}

	@Override
	public int getBatchSize() {
		return entities.size();
	}
});
*/		
